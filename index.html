<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agent Survival Simulation - Advanced Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f0f23;
            color: #ccc;
            overflow-x: hidden;
        }
        
        .main-container {
            display: flex;
            height: 100vh;
        }
        
        .simulation-panel {
            width: 650px;
            background: #1a1a2e;
            padding: 20px;
            border-right: 2px solid #16213e;
            display: flex;
            flex-direction: column;
        }
        
        .dashboard-panel {
            flex: 1;
            background: #0f0f23;
            overflow-y: auto;
        }
        
        h1 {
            color: #00ff41;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff41;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 8px 16px;
            background: #16213e;
            color: #00ff41;
            border: 1px solid #00ff41;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        button:hover {
            background: #00ff41;
            color: #0f0f23;
            box-shadow: 0 0 10px #00ff41;
        }
        
        .canvas-wrapper {
            position: relative;
            background: #000;
            border: 2px solid #16213e;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
        }
        
        canvas {
            display: block;
            background: #0a0a0a;
        }
        
        .quick-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-card {
            background: #16213e;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #1e3a5f;
        }
        
        .stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #00ff41;
        }
        
        /* Dashboard Tabs */
        .tabs {
            display: flex;
            background: #16213e;
            border-bottom: 2px solid #1e3a5f;
        }
        
        .tab {
            padding: 12px 24px;
            background: transparent;
            color: #888;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .tab.active {
            background: #0f0f23;
            color: #00ff41;
            border-bottom: 2px solid #00ff41;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            height: calc(100vh - 60px);
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Agent Cards */
        .agent-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .agent-card {
            background: #16213e;
            border: 1px solid #1e3a5f;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .agent-card:hover {
            border-color: #00ff41;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }
        
        .agent-card.selected {
            border-color: #00ff41;
            background: #1e3a5f;
        }
        
        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #1e3a5f;
        }
        
        .agent-id {
            font-weight: bold;
            font-size: 14px;
        }
        
        .agent-type {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .type-aggressive { background: #ff4444; color: #000; }
        .type-cooperative { background: #44ff44; color: #000; }
        .type-balanced { background: #4444ff; color: #fff; }
        .type-reproductive { background: #ff44ff; color: #000; }
        
        .agent-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }
        
        .agent-stat {
            display: flex;
            justify-content: space-between;
        }
        
        .agent-stat-label {
            color: #888;
        }
        
        .agent-stat-value {
            color: #00ff41;
            font-weight: 600;
        }
        
        /* Table */
        .data-table {
            width: 100%;
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .table-controls {
            padding: 15px;
            background: #1e3a5f;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .table-controls input {
            padding: 6px 12px;
            background: #0f0f23;
            border: 1px solid #00ff41;
            color: #00ff41;
            border-radius: 4px;
        }
        
        .table-controls select {
            padding: 6px 12px;
            background: #0f0f23;
            border: 1px solid #00ff41;
            color: #00ff41;
            border-radius: 4px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: #1e3a5f;
            padding: 10px;
            text-align: left;
            color: #00ff41;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        th:hover {
            background: #2a4a6f;
        }
        
        td {
            padding: 8px 10px;
            border-bottom: 1px solid #1e3a5f;
        }
        
        tr:hover {
            background: #1e3a5f;
        }
        
        /* Charts */
        .chart-container {
            background: #16213e;
            border: 1px solid #1e3a5f;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .chart-title {
            color: #00ff41;
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .chart-canvas {
            background: #0a0a0a;
            border-radius: 4px;
        }
        
        /* Heat Map */
        .heatmap-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .heatmap-section {
            background: #16213e;
            border: 1px solid #1e3a5f;
            border-radius: 8px;
            padding: 15px;
        }
        
        .heatmap-title {
            color: #00ff41;
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        /* Family Tree */
        .family-tree {
            background: #16213e;
            border: 1px solid #1e3a5f;
            border-radius: 8px;
            padding: 20px;
            min-height: 500px;
        }
        
        .tree-svg {
            width: 100%;
            height: 500px;
        }
        
        .tree-node {
            cursor: pointer;
        }
        
        .tree-link {
            fill: none;
            stroke: #1e3a5f;
            stroke-width: 2;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #0f0f23;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #16213e;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #1e3a5f;
        }
        
        /* Loading */
        .loading {
            text-align: center;
            padding: 50px;
            color: #888;
        }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Simulation Panel -->
        <div class="simulation-panel">
            <h1>üß¨ AI Agent Survival Simulation</h1>
            
            <div class="controls">
                <button id="startBtn">‚ñ∂ Start</button>
                <button id="pauseBtn">‚è∏ Pause</button>
                <button id="resetBtn">üîÑ Reset</button>
                <button id="speedBtn">‚ö° Speed: Normal</button>
                <button id="trackBtn">üìç Track Selected</button>
            </div>
            
            <div class="canvas-wrapper">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <div class="quick-stats">
                <div class="stat-card">
                    <div class="stat-label">Time Step</div>
                    <div class="stat-value" id="timeStep">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Population</div>
                    <div class="stat-value" id="population">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Resources</div>
                    <div class="stat-value" id="resources">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Energy</div>
                    <div class="stat-value" id="avgEnergy">0</div>
                </div>
            </div>
        </div>
        
        <!-- Dashboard Panel -->
        <div class="dashboard-panel">
            <div class="tabs">
                <button class="tab active" data-tab="agents">Agent Cards</button>
                <button class="tab" data-tab="table">Data Table</button>
                <button class="tab" data-tab="charts">Time Series</button>
                <button class="tab" data-tab="heatmap">Heat Maps</button>
                <button class="tab" data-tab="family">Family Trees</button>
            </div>
            
            <!-- Agent Cards Tab -->
            <div class="tab-content active" id="agents-tab">
                <div class="agent-grid" id="agentGrid"></div>
            </div>
            
            <!-- Data Table Tab -->
            <div class="tab-content" id="table-tab">
                <div class="data-table">
                    <div class="table-controls">
                        <input type="text" placeholder="Search agents..." id="searchInput">
                        <select id="typeFilter">
                            <option value="">All Types</option>
                            <option value="aggressive">Aggressive</option>
                            <option value="cooperative">Cooperative</option>
                            <option value="balanced">Balanced</option>
                            <option value="reproductive">Reproductive</option>
                        </select>
                        <button id="exportBtn">üì• Export CSV</button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table id="dataTable">
                            <thead>
                                <tr>
                                    <th data-sort="id">ID</th>
                                    <th data-sort="type">Type</th>
                                    <th data-sort="age">Age</th>
                                    <th data-sort="energy">Energy</th>
                                    <th data-sort="x">X</th>
                                    <th data-sort="y">Y</th>
                                    <th data-sort="attacks">Attacks</th>
                                    <th data-sort="shares">Shares</th>
                                    <th data-sort="children">Children</th>
                                    <th data-sort="gathered">Gathered</th>
                                    <th data-sort="distance">Distance</th>
                                    <th data-sort="efficiency">Efficiency</th>
                                </tr>
                            </thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- Charts Tab -->
            <div class="tab-content" id="charts-tab">
                <div class="chart-container">
                    <div class="chart-title">Population Dynamics</div>
                    <canvas id="populationChart" class="chart-canvas" width="800" height="200"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Average Energy by Type</div>
                    <canvas id="energyChart" class="chart-canvas" width="800" height="200"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Action Distribution</div>
                    <canvas id="actionChart" class="chart-canvas" width="800" height="200"></canvas>
                </div>
            </div>
            
            <!-- Heat Map Tab -->
            <div class="tab-content" id="heatmap-tab">
                <div class="heatmap-container">
                    <div class="heatmap-section">
                        <div class="heatmap-title">Movement Heat Map</div>
                        <canvas id="movementHeatmap" width="400" height="400"></canvas>
                    </div>
                    <div class="heatmap-section">
                        <div class="heatmap-title">Resource Collection Heat Map</div>
                        <canvas id="resourceHeatmap" width="400" height="400"></canvas>
                    </div>
                    <div class="heatmap-section">
                        <div class="heatmap-title">Conflict Zone Heat Map</div>
                        <canvas id="conflictHeatmap" width="400" height="400"></canvas>
                    </div>
                    <div class="heatmap-section">
                        <div class="heatmap-title">Reproduction Heat Map</div>
                        <canvas id="reproductionHeatmap" width="400" height="400"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Family Tree Tab -->
            <div class="tab-content" id="family-tab">
                <div class="family-tree">
                    <div class="chart-title">Agent Lineages</div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff4444;"></div>
                            <span>Aggressive</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #44ff44;"></div>
                            <span>Cooperative</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4444ff;"></div>
                            <span>Balanced</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff44ff;"></div>
                            <span>Reproductive</span>
                        </div>
                    </div>
                    <svg id="familyTreeSvg" class="tree-svg"></svg>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const GRID_SIZE = 30;
        const CELL_SIZE = 20;
        const INITIAL_AGENTS = 20;
        const INITIAL_ENERGY = 100;
        const MAX_AGENTS = 60;
        const ENERGY_SPAWN_RATE = 0.05;
        const ENERGY_VALUE = 50;
        const MOVE_COST = 2;
        const STAY_COST = 1;
        const REPRODUCE_COST = 150;
        const ATTACK_REWARD_MULTIPLIER = 0.8;
        const VIEW_RANGE = 2;
        const MAX_HISTORY = 100;
        
        // Agent types
        const AgentTypes = {
            AGGRESSIVE: 'aggressive',
            COOPERATIVE: 'cooperative',
            BALANCED: 'balanced',
            REPRODUCTIVE: 'reproductive'
        };
        
        // Game state
        let grid = [];
        let agents = [];
        let deadAgents = [];
        let timeStep = 0;
        let isRunning = false;
        let gameSpeed = 100;
        let selectedAgentId = null;
        let trackingAgent = false;
        
        // History tracking
        let populationHistory = [];
        let typeHistory = { aggressive: [], cooperative: [], balanced: [], reproductive: [] };
        let actionHistory = { move: [], stay: [], attack: [], share: [], reproduce: [], gather: [] };
        
        // Heat maps
        let movementHeatMap = [];
        let resourceHeatMap = [];
        let conflictHeatMap = [];
        let reproductionHeatMap = [];
        
        // Initialize heat maps
        for (let i = 0; i < GRID_SIZE; i++) {
            movementHeatMap[i] = new Array(GRID_SIZE).fill(0);
            resourceHeatMap[i] = new Array(GRID_SIZE).fill(0);
            conflictHeatMap[i] = new Array(GRID_SIZE).fill(0);
            reproductionHeatMap[i] = new Array(GRID_SIZE).fill(0);
        }
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = GRID_SIZE * CELL_SIZE;
        canvas.height = GRID_SIZE * CELL_SIZE;
        
        class Agent {
            constructor(x, y, type, parentId = null, generation = 0) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.type = type;
                this.energy = INITIAL_ENERGY;
                this.peakEnergy = INITIAL_ENERGY;
                this.age = 0;
                this.generation = generation;
                this.parentId = parentId;
                this.children = [];
                this.birthLocation = { x, y };
                
                // Action tracking
                this.totalAttacks = 0;
                this.successfulAttacks = 0;
                this.totalShares = 0;
                this.energyShared = 0;
                this.energyReceived = 0;
                this.reproductionCount = 0;
                this.lastAction = 'born';
                this.actionCounts = { move: 0, stay: 0, attack: 0, share: 0, reproduce: 0, gather: 0 };
                
                // Movement tracking
                this.distanceTraveled = 0;
                this.uniqueCellsVisited = new Set([`${x},${y}`]);
                this.movementHistory = [];
                this.homeRange = { minX: x, maxX: x, minY: y, maxY: y };
                
                // Resource tracking
                this.energySourcesCollected = 0;
                this.energyGathered = 0;
                this.scavengedEnergy = 0;
                
                // Social tracking
                this.encounters = 0;
                this.aggressiveEncounters = 0;
                this.cooperativeEncounters = 0;
                this.timeAlone = 0;
                this.timeNearOthers = 0;
                this.sharedWith = {};
                this.attackedBy = [];
                
                // Survival tracking
                this.nearDeathEvents = 0;
                this.lowestEnergy = INITIAL_ENERGY;
                
                this.setPersonality();
            }
            
            setPersonality() {
                switch(this.type) {
                    case AgentTypes.AGGRESSIVE:
                        this.attackThreshold = 0.7;
                        this.shareThreshold = 0.05;
                        this.reproduceThreshold = 200;
                        this.exploreRate = 0.8;
                        break;
                    case AgentTypes.COOPERATIVE:
                        this.attackThreshold = 0.02;
                        this.shareThreshold = 0.6;
                        this.reproduceThreshold = 180;
                        this.exploreRate = 0.5;
                        break;
                    case AgentTypes.BALANCED:
                        this.attackThreshold = 0.3;
                        this.shareThreshold = 0.3;
                        this.reproduceThreshold = 170;
                        this.exploreRate = 0.6;
                        break;
                    case AgentTypes.REPRODUCTIVE:
                        this.attackThreshold = 0.1;
                        this.shareThreshold = 0.1;
                        this.reproduceThreshold = 155;
                        this.exploreRate = 0.4;
                        break;
                }
            }
            
            getLocalView() {
                const view = { energy: [], agents: [], empty: [] };
                
                for (let dx = -VIEW_RANGE; dx <= VIEW_RANGE; dx++) {
                    for (let dy = -VIEW_RANGE; dy <= VIEW_RANGE; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = this.x + dx;
                        const ny = this.y + dy;
                        
                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                            if (grid[ny][nx] === 'energy') {
                                view.energy.push({x: nx, y: ny, dx, dy});
                            } else {
                                const agent = agents.find(a => a.x === nx && a.y === ny);
                                if (agent) {
                                    view.agents.push({agent, dx, dy});
                                } else {
                                    view.empty.push({x: nx, y: ny, dx, dy});
                                }
                            }
                        }
                    }
                }
                
                return view;
            }
            
            decideAction() {
                const view = this.getLocalView();
                
                // Update social metrics
                if (view.agents.length > 0) {
                    this.timeNearOthers++;
                    this.encounters += view.agents.length;
                } else {
                    this.timeAlone++;
                }
                
                // Check if we should reproduce
                if (this.energy >= this.reproduceThreshold && agents.length < MAX_AGENTS) {
                    if (Math.random() < 0.5) {
                        return this.reproduce();
                    }
                }
                
                // Check for energy sources
                if (view.energy.length > 0) {
                    const closest = view.energy.reduce((a, b) => 
                        Math.abs(a.dx) + Math.abs(a.dy) < Math.abs(b.dx) + Math.abs(b.dy) ? a : b
                    );
                    return this.moveToward(closest.x, closest.y);
                }
                
                // Check for nearby agents
                if (view.agents.length > 0) {
                    const nearAgent = view.agents
                        .filter(a => Math.abs(a.dx) <= 1 && Math.abs(a.dy) <= 1)
                        .sort((a, b) => a.agent.energy - b.agent.energy)[0];
                    
                    if (nearAgent) {
                        const shouldAttack = this.energy < 50 && Math.random() < this.attackThreshold;
                        const shouldShare = this.energy > 150 && Math.random() < this.shareThreshold;
                        
                        if (shouldAttack && nearAgent.agent.energy > 20) {
                            return this.attack(nearAgent.agent);
                        } else if (shouldShare && nearAgent.agent.energy < 50) {
                            return this.share(nearAgent.agent);
                        }
                    }
                }
                
                // Explore or stay
                if (Math.random() < this.exploreRate) {
                    return this.randomMove();
                } else {
                    return this.stay();
                }
            }
            
            moveToward(targetX, targetY) {
                const oldX = this.x;
                const oldY = this.y;
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                
                let newX = this.x;
                let newY = this.y;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    newX += dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    newY += dy > 0 ? 1 : -1;
                }
                
                if (this.canMoveTo(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                    this.energy -= MOVE_COST;
                    this.lastAction = 'move';
                    this.actionCounts.move++;
                    this.distanceTraveled++;
                    this.uniqueCellsVisited.add(`${newX},${newY}`);
                    this.updateHomeRange();
                    movementHeatMap[newY][newX]++;
                    
                    if (grid[this.y][this.x] === 'energy') {
                        this.collectEnergy();
                    }
                } else {
                    this.stay();
                }
            }
            
            randomMove() {
                const directions = [
                    {dx: 0, dy: -1}, {dx: 1, dy: 0},
                    {dx: 0, dy: 1}, {dx: -1, dy: 0}
                ];
                const dir = directions[Math.floor(Math.random() * directions.length)];
                const newX = this.x + dir.dx;
                const newY = this.y + dir.dy;
                
                if (this.canMoveTo(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                    this.energy -= MOVE_COST;
                    this.lastAction = 'explore';
                    this.actionCounts.move++;
                    this.distanceTraveled++;
                    this.uniqueCellsVisited.add(`${newX},${newY}`);
                    this.updateHomeRange();
                    movementHeatMap[newY][newX]++;
                    
                    if (grid[this.y][this.x] === 'energy') {
                        this.collectEnergy();
                    }
                } else {
                    this.stay();
                }
            }
            
            stay() {
                this.energy -= STAY_COST;
                this.lastAction = 'stay';
                this.actionCounts.stay++;
            }
            
            canMoveTo(x, y) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
                    return false;
                }
                return !agents.some(a => a.x === x && a.y === y && a.id !== this.id);
            }
            
            attack(target) {
                if (Math.abs(target.x - this.x) <= 1 && Math.abs(target.y - this.y) <= 1) {
                    this.totalAttacks++;
                    this.aggressiveEncounters++;
                    const stolenEnergy = Math.floor(target.energy * ATTACK_REWARD_MULTIPLIER);
                    this.energy += stolenEnergy;
                    this.scavengedEnergy += stolenEnergy;
                    target.energy = 0;
                    target.attackedBy.push(this.id);
                    this.successfulAttacks++;
                    this.lastAction = 'attack';
                    this.actionCounts.attack++;
                    conflictHeatMap[this.y][this.x]++;
                    return true;
                }
                return false;
            }
            
            share(target) {
                if (Math.abs(target.x - this.x) <= 1 && Math.abs(target.y - this.y) <= 1) {
                    const shareAmount = Math.floor(this.energy * 0.2);
                    if (shareAmount > 0) {
                        this.totalShares++;
                        this.cooperativeEncounters++;
                        this.energyShared += shareAmount;
                        this.energy -= shareAmount;
                        target.energy += shareAmount;
                        target.energyReceived += shareAmount;
                        
                        if (!this.sharedWith[target.id]) {
                            this.sharedWith[target.id] = 0;
                        }
                        this.sharedWith[target.id]++;
                        
                        this.lastAction = 'share';
                        this.actionCounts.share++;
                        return true;
                    }
                }
                return false;
            }
            
            reproduce() {
                if (this.energy >= REPRODUCE_COST && agents.length < MAX_AGENTS) {
                    const adjacentCells = [
                        {x: this.x + 1, y: this.y},
                        {x: this.x - 1, y: this.y},
                        {x: this.x, y: this.y + 1},
                        {x: this.x, y: this.y - 1}
                    ].filter(cell => 
                        cell.x >= 0 && cell.x < GRID_SIZE &&
                        cell.y >= 0 && cell.y < GRID_SIZE &&
                        !agents.some(a => a.x === cell.x && a.y === cell.y)
                    );
                    
                    if (adjacentCells.length > 0) {
                        const cell = adjacentCells[Math.floor(Math.random() * adjacentCells.length)];
                        this.energy -= REPRODUCE_COST;
                        this.reproductionCount++;
                        
                        let childType = this.type;
                        if (Math.random() < 0.1) {
                            const types = Object.values(AgentTypes);
                            childType = types[Math.floor(Math.random() * types.length)];
                        }
                        
                        const child = new Agent(cell.x, cell.y, childType, this.id, this.generation + 1);
                        child.energy = REPRODUCE_COST / 2;
                        agents.push(child);
                        this.children.push(child.id);
                        this.lastAction = 'reproduce';
                        this.actionCounts.reproduce++;
                        reproductionHeatMap[this.y][this.x]++;
                        return true;
                    }
                }
                return false;
            }
            
            collectEnergy() {
                this.energy += ENERGY_VALUE;
                this.energySourcesCollected++;
                this.energyGathered += ENERGY_VALUE;
                grid[this.y][this.x] = null;
                this.lastAction = 'gather';
                this.actionCounts.gather++;
                resourceHeatMap[this.y][this.x]++;
            }
            
            updateHomeRange() {
                this.homeRange.minX = Math.min(this.homeRange.minX, this.x);
                this.homeRange.maxX = Math.max(this.homeRange.maxX, this.x);
                this.homeRange.minY = Math.min(this.homeRange.minY, this.y);
                this.homeRange.maxY = Math.max(this.homeRange.maxY, this.y);
            }
            
            update() {
                this.age++;
                
                // Track energy
                if (this.energy > this.peakEnergy) {
                    this.peakEnergy = this.energy;
                }
                if (this.energy < this.lowestEnergy) {
                    this.lowestEnergy = this.energy;
                }
                if (this.energy < 20) {
                    this.nearDeathEvents++;
                }
                
                // Make decision
                this.decideAction();
                
                // Check death
                if (this.energy <= 0) {
                    this.energy = 0;
                    deadAgents.push(this);
                    return false;
                }
                return true;
            }
            
            getEfficiency() {
                const totalSpent = (this.actionCounts.move * MOVE_COST) + 
                                 (this.actionCounts.stay * STAY_COST) + 
                                 (this.reproductionCount * REPRODUCE_COST);
                const totalGained = this.energyGathered + this.scavengedEnergy;
                return totalSpent > 0 ? (totalGained / totalSpent).toFixed(2) : 0;
            }
            
            getFitnessScore() {
                const survivalScore = this.age;
                const reproductiveScore = this.children.length * 100;
                const energyScore = this.peakEnergy;
                return survivalScore + reproductiveScore + energyScore;
            }
            
            getColor() {
                const alpha = Math.min(1, Math.max(0.3, this.energy / 200));
                switch(this.type) {
                    case AgentTypes.AGGRESSIVE:
                        return `rgba(255, 68, 68, ${alpha})`;
                    case AgentTypes.COOPERATIVE:
                        return `rgba(68, 255, 68, ${alpha})`;
                    case AgentTypes.BALANCED:
                        return `rgba(68, 68, 255, ${alpha})`;
                    case AgentTypes.REPRODUCTIVE:
                        return `rgba(255, 68, 255, ${alpha})`;
                    default:
                        return `rgba(128, 128, 128, ${alpha})`;
                }
            }
        }
        
        // Initialize functions
        function initializeGrid() {
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid[y][x] = Math.random() < 0.03 ? 'energy' : null;
                }
            }
        }
        
        function initializeAgents() {
            agents = [];
            deadAgents = [];
            const types = Object.values(AgentTypes);
            
            for (let i = 0; i < INITIAL_AGENTS; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while (agents.some(a => a.x === x && a.y === y));
                
                const type = types[i % types.length];
                agents.push(new Agent(x, y, type));
            }
        }
        
        function spawnEnergy() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === null && Math.random() < ENERGY_SPAWN_RATE) {
                        if (!agents.some(a => a.x === x && a.y === y)) {
                            grid[y][x] = 'energy';
                        }
                    }
                }
            }
        }
        
        // Update simulation
        function updateSimulation() {
            if (!isRunning) return;
            
            timeStep++;
            
            // Update agents
            agents = agents.filter(agent => agent.update());
            
            // Spawn new energy
            if (timeStep % 5 === 0) {
                spawnEnergy();
            }
            
            // Update history
            updateHistory();
            
            // Update displays
            draw();
            updateQuickStats();
            updateAgentCards();
            updateDataTable();
            updateCharts();
            updateHeatMaps();
            updateFamilyTree();
            
            // Continue simulation
            setTimeout(updateSimulation, gameSpeed);
        }
        
        // Drawing functions
        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid lines
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }
            
            // Energy sources
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 'energy') {
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(
                            x * CELL_SIZE + CELL_SIZE / 2,
                            y * CELL_SIZE + CELL_SIZE / 2,
                            CELL_SIZE / 3,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
            
            // Agents
            agents.forEach(agent => {
                // Highlight selected agent
                if (agent.id === selectedAgentId) {
                    ctx.strokeStyle = '#00ff41';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        agent.x * CELL_SIZE,
                        agent.y * CELL_SIZE,
                        CELL_SIZE,
                        CELL_SIZE
                    );
                }
                
                // Draw agent
                ctx.fillStyle = agent.getColor();
                ctx.fillRect(
                    agent.x * CELL_SIZE + 2,
                    agent.y * CELL_SIZE + 2,
                    CELL_SIZE - 4,
                    CELL_SIZE - 4
                );
                
                // Energy bar
                const barWidth = CELL_SIZE - 6;
                const barHeight = 2;
                const energyPercent = Math.min(1, agent.energy / 200);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(
                    agent.x * CELL_SIZE + 3,
                    agent.y * CELL_SIZE + CELL_SIZE - 5,
                    barWidth,
                    barHeight
                );
                
                ctx.fillStyle = energyPercent > 0.5 ? '#00ff00' : 
                               energyPercent > 0.25 ? '#ffff00' : '#ff0000';
                ctx.fillRect(
                    agent.x * CELL_SIZE + 3,
                    agent.y * CELL_SIZE + CELL_SIZE - 5,
                    barWidth * energyPercent,
                    barHeight
                );
            });
            
            // Track selected agent
            if (trackingAgent && selectedAgentId) {
                const agent = agents.find(a => a.id === selectedAgentId);
                if (agent) {
                    ctx.strokeStyle = '#00ff41';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(
                        agent.x * CELL_SIZE + CELL_SIZE / 2,
                        agent.y * CELL_SIZE + CELL_SIZE / 2,
                        VIEW_RANGE * CELL_SIZE,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // Update functions
        function updateHistory() {
            populationHistory.push(agents.length);
            if (populationHistory.length > MAX_HISTORY) {
                populationHistory.shift();
            }
            
            const typeCounts = { aggressive: 0, cooperative: 0, balanced: 0, reproductive: 0 };
            agents.forEach(agent => typeCounts[agent.type]++);
            
            Object.keys(typeCounts).forEach(type => {
                typeHistory[type].push(typeCounts[type]);
                if (typeHistory[type].length > MAX_HISTORY) {
                    typeHistory[type].shift();
                }
            });
            
            const actions = { move: 0, stay: 0, attack: 0, share: 0, reproduce: 0, gather: 0 };
            agents.forEach(agent => {
                if (agent.lastAction in actions) {
                    actions[agent.lastAction]++;
                }
            });
            
            Object.keys(actions).forEach(action => {
                actionHistory[action].push(actions[action]);
                if (actionHistory[action].length > MAX_HISTORY) {
                    actionHistory[action].shift();
                }
            });
        }
        
        function updateQuickStats() {
            document.getElementById('timeStep').textContent = timeStep;
            document.getElementById('population').textContent = agents.length;
            
            let resourceCount = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 'energy') resourceCount++;
                }
            }
            document.getElementById('resources').textContent = resourceCount;
            
            const avgEnergy = agents.length > 0 ? 
                Math.floor(agents.reduce((sum, a) => sum + a.energy, 0) / agents.length) : 0;
            document.getElementById('avgEnergy').textContent = avgEnergy;
        }
        
        function updateAgentCards() {
            const grid = document.getElementById('agentGrid');
            grid.innerHTML = '';
            
            agents.forEach(agent => {
                const card = document.createElement('div');
                card.className = 'agent-card';
                if (agent.id === selectedAgentId) {
                    card.classList.add('selected');
                }
                
                card.innerHTML = `
                    <div class="agent-header">
                        <span class="agent-id">${agent.id.substr(0, 6)}</span>
                        <span class="agent-type type-${agent.type}">${agent.type}</span>
                    </div>
                    <div class="agent-stats">
                        <div class="agent-stat">
                            <span class="agent-stat-label">Age:</span>
                            <span class="agent-stat-value">${agent.age}</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Energy:</span>
                            <span class="agent-stat-value">${agent.energy}</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Position:</span>
                            <span class="agent-stat-value">(${agent.x}, ${agent.y})</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Children:</span>
                            <span class="agent-stat-value">${agent.children.length}</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Attacks:</span>
                            <span class="agent-stat-value">${agent.totalAttacks}</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Shares:</span>
                            <span class="agent-stat-value">${agent.totalShares}</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Distance:</span>
                            <span class="agent-stat-value">${agent.distanceTraveled}</span>
                        </div>
                        <div class="agent-stat">
                            <span class="agent-stat-label">Efficiency:</span>
                            <span class="agent-stat-value">${agent.getEfficiency()}</span>
                        </div>
                    </div>
                `;
                
                card.addEventListener('click', () => {
                    selectedAgentId = agent.id;
                    updateAgentCards();
                });
                
                grid.appendChild(card);
            });
        }
        
        function updateDataTable() {
            const tbody = document.getElementById('tableBody');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const typeFilter = document.getElementById('typeFilter').value;
            
            let filteredAgents = agents.filter(agent => {
                const matchesSearch = agent.id.toLowerCase().includes(searchTerm);
                const matchesType = !typeFilter || agent.type === typeFilter;
                return matchesSearch && matchesType;
            });
            
            tbody.innerHTML = '';
            filteredAgents.forEach(agent => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${agent.id.substr(0, 6)}</td>
                    <td><span class="agent-type type-${agent.type}">${agent.type}</span></td>
                    <td>${agent.age}</td>
                    <td>${agent.energy}</td>
                    <td>${agent.x}</td>
                    <td>${agent.y}</td>
                    <td>${agent.totalAttacks}</td>
                    <td>${agent.totalShares}</td>
                    <td>${agent.children.length}</td>
                    <td>${agent.energyGathered}</td>
                    <td>${agent.distanceTraveled}</td>
                    <td>${agent.getEfficiency()}</td>
                `;
                
                row.addEventListener('click', () => {
                    selectedAgentId = agent.id;
                    updateAgentCards();
                });
            });
        }
        
        function updateCharts() {
            // Population chart
            const popCanvas = document.getElementById('populationChart');
            const popCtx = popCanvas.getContext('2d');
            popCtx.clearRect(0, 0, popCanvas.width, popCanvas.height);
            
            if (populationHistory.length > 1) {
                const maxPop = Math.max(...populationHistory, 1);
                const xStep = popCanvas.width / populationHistory.length;
                const yScale = popCanvas.height / maxPop;
                
                popCtx.strokeStyle = '#00ff41';
                popCtx.lineWidth = 2;
                popCtx.beginPath();
                populationHistory.forEach((pop, i) => {
                    const x = i * xStep;
                    const y = popCanvas.height - (pop * yScale);
                    if (i === 0) popCtx.moveTo(x, y);
                    else popCtx.lineTo(x, y);
                });
                popCtx.stroke();
            }
            
            // Energy by type chart
            const energyCanvas = document.getElementById('energyChart');
            const energyCtx = energyCanvas.getContext('2d');
            energyCtx.clearRect(0, 0, energyCanvas.width, energyCanvas.height);
            
            const colors = {
                aggressive: '#ff4444',
                cooperative: '#44ff44',
                balanced: '#4444ff',
                reproductive: '#ff44ff'
            };
            
            Object.keys(typeHistory).forEach((type, index) => {
                const history = typeHistory[type];
                if (history.length > 1) {
                    const xStep = energyCanvas.width / history.length;
                    const maxCount = Math.max(...Object.values(typeHistory).flat(), 1);
                    const yScale = energyCanvas.height / maxCount;
                    
                    energyCtx.strokeStyle = colors[type];
                    energyCtx.lineWidth = 2;
                    energyCtx.beginPath();
                    history.forEach((count, i) => {
                        const x = i * xStep;
                        const y = energyCanvas.height - (count * yScale);
                        if (i === 0) energyCtx.moveTo(x, y);
                        else energyCtx.lineTo(x, y);
                    });
                    energyCtx.stroke();
                }
            });
            
            // Action distribution chart
            const actionCanvas = document.getElementById('actionChart');
            const actionCtx = actionCanvas.getContext('2d');
            actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);
            
            const actionColors = {
                move: '#00ff41',
                stay: '#888888',
                attack: '#ff4444',
                share: '#44ff44',
                reproduce: '#ff44ff',
                gather: '#ffaa00'
            };
            
            const barWidth = actionCanvas.width / 6;
            const currentActions = agents.reduce((acc, agent) => {
                Object.keys(agent.actionCounts).forEach(action => {
                    acc[action] = (acc[action] || 0) + agent.actionCounts[action];
                });
                return acc;
            }, {});
            
            const maxActions = Math.max(...Object.values(currentActions), 1);
            Object.keys(actionColors).forEach((action, i) => {
                const count = currentActions[action] || 0;
                const height = (count / maxActions) * actionCanvas.height * 0.8;
                
                actionCtx.fillStyle = actionColors[action];
                actionCtx.fillRect(
                    i * barWidth + 10,
                    actionCanvas.height - height,
                    barWidth - 20,
                    height
                );
                
                actionCtx.fillStyle = '#888';
                actionCtx.font = '10px Arial';
                actionCtx.textAlign = 'center';
                actionCtx.fillText(
                    action,
                    i * barWidth + barWidth / 2,
                    actionCanvas.height - 5
                );
            });
        }
        
        function updateHeatMaps() {
            // Movement heat map
            drawHeatMap('movementHeatmap', movementHeatMap, '#00ff41');
            
            // Resource heat map
            drawHeatMap('resourceHeatmap', resourceHeatMap, '#ffaa00');
            
            // Conflict heat map
            drawHeatMap('conflictHeatmap', conflictHeatMap, '#ff4444');
            
            // Reproduction heat map
            drawHeatMap('reproductionHeatmap', reproductionHeatMap, '#ff44ff');
        }
        
        function drawHeatMap(canvasId, data, color) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const cellSize = canvas.width / GRID_SIZE;
            
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const maxValue = Math.max(...data.flat(), 1);
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const value = data[y][x];
                    if (value > 0) {
                        const intensity = value / maxValue;
                        ctx.fillStyle = color;
                        ctx.globalAlpha = intensity;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            
            // Draw grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
        }
        
        function updateFamilyTree() {
            const svg = document.getElementById('familyTreeSvg');
            svg.innerHTML = '';
            
            // Build family tree data
            const roots = agents.filter(a => !a.parentId);
            const allAgents = [...agents, ...deadAgents];
            
            const typeColors = {
                aggressive: '#ff4444',
                cooperative: '#44ff44',
                balanced: '#4444ff',
                reproductive: '#ff44ff'
            };
            
            let y = 20;
            roots.forEach(root => {
                drawBranch(svg, root, 20, y, allAgents, typeColors);
                y += 80;
            });
        }
        
        function drawBranch(svg, agent, x, y, allAgents, colors) {
            // Draw node
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', 5);
            circle.setAttribute('fill', colors[agent.type]);
            circle.setAttribute('class', 'tree-node');
            circle.setAttribute('data-id', agent.id);
            
            if (!agents.find(a => a.id === agent.id)) {
                circle.setAttribute('opacity', '0.3');
            }
            
            svg.appendChild(circle);
            
            // Draw children
            const children = allAgents.filter(a => a.parentId === agent.id);
            if (children.length > 0) {
                const childX = x + 50;
                let childY = y - (children.length - 1) * 15;
                
                children.forEach(child => {
                    // Draw line
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', childX);
                    line.setAttribute('y2', childY);
                    line.setAttribute('class', 'tree-link');
                    svg.appendChild(line);
                    
                    // Recursively draw child
                    drawBranch(svg, child, childX, childY, allAgents, colors);
                    childY += 30;
                });
            }
        }
        
        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                updateSimulation();
            }
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            timeStep = 0;
            populationHistory = [];
            typeHistory = { aggressive: [], cooperative: [], balanced: [], reproductive: [] };
            actionHistory = { move: [], stay: [], attack: [], share: [], reproduce: [], gather: [] };
            
            // Reset heat maps
            for (let i = 0; i < GRID_SIZE; i++) {
                movementHeatMap[i].fill(0);
                resourceHeatMap[i].fill(0);
                conflictHeatMap[i].fill(0);
                reproductionHeatMap[i].fill(0);
            }
            
            initializeGrid();
            initializeAgents();
            draw();
            updateQuickStats();
            updateAgentCards();
            updateDataTable();
            updateCharts();
            updateHeatMaps();
            updateFamilyTree();
        });
        
        document.getElementById('speedBtn').addEventListener('click', () => {
            const speeds = [
                {label: 'Slow', value: 500},
                {label: 'Normal', value: 100},
                {label: 'Fast', value: 50},
                {label: 'Ultra', value: 10}
            ];
            
            const currentIndex = speeds.findIndex(s => s.value === gameSpeed);
            const nextIndex = (currentIndex + 1) % speeds.length;
            gameSpeed = speeds[nextIndex].value;
            
            const btn = document.getElementById('speedBtn');
            btn.textContent = `‚ö° Speed: ${speeds[nextIndex].label}`;
        });
        
        document.getElementById('trackBtn').addEventListener('click', () => {
            trackingAgent = !trackingAgent;
            const btn = document.getElementById('trackBtn');
            btn.textContent = trackingAgent ? 'üìç Tracking' : 'üìç Track Selected';
        });
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });
        
        // Table sorting
        document.querySelectorAll('th[data-sort]').forEach(header => {
            header.addEventListener('click', () => {
                const sortBy = header.dataset.sort;
                agents.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch(sortBy) {
                        case 'id': aVal = a.id; bVal = b.id; break;
                        case 'type': aVal = a.type; bVal = b.type; break;
                        case 'age': aVal = a.age; bVal = b.age; break;
                        case 'energy': aVal = a.energy; bVal = b.energy; break;
                        case 'x': aVal = a.x; bVal = b.x; break;
                        case 'y': aVal = a.y; bVal = b.y; break;
                        case 'attacks': aVal = a.totalAttacks; bVal = b.totalAttacks; break;
                        case 'shares': aVal = a.totalShares; bVal = b.totalShares; break;
                        case 'children': aVal = a.children.length; bVal = b.children.length; break;
                        case 'gathered': aVal = a.energyGathered; bVal = b.energyGathered; break;
                        case 'distance': aVal = a.distanceTraveled; bVal = b.distanceTraveled; break;
                        case 'efficiency': aVal = parseFloat(a.getEfficiency()); bVal = parseFloat(b.getEfficiency()); break;
                    }
                    
                    if (typeof aVal === 'string') {
                        return aVal.localeCompare(bVal);
                    }
                    return bVal - aVal;
                });
                updateDataTable();
            });
        });
        
        // Search and filter
        document.getElementById('searchInput').addEventListener('input', updateDataTable);
        document.getElementById('typeFilter').addEventListener('change', updateDataTable);
        
        // Export CSV
        document.getElementById('exportBtn').addEventListener('click', () => {
            let csv = 'ID,Type,Age,Energy,X,Y,Attacks,Shares,Children,Gathered,Distance,Efficiency\n';
            agents.forEach(agent => {
                csv += `${agent.id},${agent.type},${agent.age},${agent.energy},${agent.x},${agent.y},`;
                csv += `${agent.totalAttacks},${agent.totalShares},${agent.children.length},`;
                csv += `${agent.energyGathered},${agent.distanceTraveled},${agent.getEfficiency()}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `agent_data_${timeStep}.csv`;
            a.click();
        });
        
        // Canvas click to select agent
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
            
            const agent = agents.find(a => a.x === x && a.y === y);
            if (agent) {
                selectedAgentId = agent.id;
                updateAgentCards();
            }
        });
        
        // Initialize
        initializeGrid();
        initializeAgents();
        draw();
        updateQuickStats();
        updateAgentCards();
        updateDataTable();
        updateCharts();
        updateHeatMaps();
        updateFamilyTree();
    </script>
</body>
</html>